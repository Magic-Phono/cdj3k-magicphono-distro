--- a/drivers/net/phy/Kconfig	2018-04-11 10:41:31.053783000 +0900
+++ b/drivers/net/phy/Kconfig	2018-04-18 10:42:34.329702133 +0900
@@ -294,6 +294,11 @@ config REALTEK_PHY
 	---help---
 	  Supports the Realtek 821x PHY.
 
+config RTL8367_PHY
+	tristate "Realtek PTL8367"
+	---help---
+	  Supports the Realtek 8367SB PHY.
+
 config SMSC_PHY
 	tristate "SMSC PHYs"
 	---help---

--- a/drivers/net/phy/Makefile	2018-04-09 13:42:40.662524000 +0900
+++ b/drivers/net/phy/Makefile	2018-04-18 10:51:42.253709443 +0900
@@ -1,5 +1,9 @@
 # Makefile for Linux PHY drivers and MDIO bus drivers
 
+ifdef CONFIG_RTL8367_PHY
+CFLAGS_mdio-bitbang.o += -I$(srctree)/drivers/net/phy/rtl8367
+endif
+
 libphy-y			:= phy.o phy_device.o mdio_bus.o mdio_device.o
 libphy-$(CONFIG_SWPHY)		+= swphy.o
 
@@ -53,3 +57,4 @@ obj-$(CONFIG_STE10XP)		+= ste10Xp.o
 obj-$(CONFIG_TERANETICS_PHY)	+= teranetics.o
 obj-$(CONFIG_VITESSE_PHY)	+= vitesse.o
 obj-$(CONFIG_XILINX_GMII2RGMII) += xilinx_gmii2rgmii.o
+obj-$(CONFIG_RTL8367_PHY)   += rtl8367/

--- a/drivers/net/phy/mdio-bitbang.c	2018-09-13 17:01:21.000000000 +0900
+++ b/drivers/net/phy/mdio-bitbang.c	2020-03-03 11:18:23.542740659 +0900
@@ -21,6 +21,11 @@
 #include <linux/mdio-bitbang.h>
 #include <linux/types.h>
 #include <linux/delay.h>
+#ifdef CONFIG_RTL8367_PHY
+#include <rtk_types.h>
+#include <rtk_error.h>
+#include <port.h>
+#endif
 
 #define MDIO_READ 2
 #define MDIO_WRITE 1
@@ -152,6 +157,7 @@ static int mdiobb_cmd_addr(struct mdiobb
 	return dev_addr;
 }
 
+#ifndef CONFIG_RTL8367_PHY
 static int mdiobb_read(struct mii_bus *bus, int phy, int reg)
 {
 	struct mdiobb_ctrl *ctrl = bus->priv;
@@ -183,7 +189,65 @@ static int mdiobb_read(struct mii_bus *b
 	mdiobb_get_bit(ctrl);
 	return ret;
 }
+#else
+int mdiobb_read(struct mii_bus *bus, int phy, int reg)
+{
+	struct mdiobb_ctrl *ctrl = bus->priv;
+	int ret, i;
+
+	if (reg & MII_ADDR_C45) {
+		reg = mdiobb_cmd_addr(ctrl, phy, reg);
+		mdiobb_cmd(ctrl, MDIO_C45_READ, phy, reg);
+	} else
+		mdiobb_cmd(ctrl, MDIO_READ, phy, reg);
+
+	ctrl->ops->set_mdio_dir(ctrl, 0);
+
+	/* check the turnaround bit: the PHY should be driving it to zero, if this
+	 * PHY is listed in phy_ignore_ta_mask as having broken TA, skip that
+	 */
+	if (mdiobb_get_bit(ctrl) != 0 &&
+	    !(bus->phy_ignore_ta_mask & (1 << phy))) {
+		/* PHY didn't drive TA low -- flush any bits it
+		 * may be trying to send.
+		 */
+		for (i = 0; i < 32; i++)
+			mdiobb_get_bit(ctrl);
+
+		return 0xffff;
+	}
+
+	ret = mdiobb_get_num(ctrl, 16);
+	mdiobb_get_bit(ctrl);
+	return ret;
+}
+EXPORT_SYMBOL(mdiobb_read);
 
+static int rtl_mdiobb_read(struct mii_bus *bus, int phy, int reg)
+{
+	int ret_val = RT_ERR_FAILED;
+	int ret_p0 = 0;
+	int ret_p3 = 0;
+
+	ret_val = rtk_port_phyReg_get(UTP_PORT0, reg, &ret_p0);
+	if (ret_val == RT_ERR_OK) {
+		if (reg == MII_BMSR) {
+			ret_val = rtk_port_phyReg_get(UTP_PORT3, reg, &ret_p3);
+			if (ret_val == RT_ERR_OK) {
+				ret_p0 |= (ret_p3 & 0x0024); /* bit5:Auto-negotiation completed, bit2:Link Status */
+			} else {
+				printk("[ERROR]:%s ret_val:%d Read error of port3 status register 0x%04x.\n", __func__, ret_val, ret_p3);
+			}
+		}
+	} else {
+		printk("[ERROR]:%s ret_val:%d Read error of port0 %d register 0x%04x.\n", __func__, ret_val, reg, ret_p0);
+	}
+
+	return ret_p0;
+}
+#endif
+
+#ifndef CONFIG_RTL8367_PHY
 static int mdiobb_write(struct mii_bus *bus, int phy, int reg, u16 val)
 {
 	struct mdiobb_ctrl *ctrl = bus->priv;
@@ -204,6 +268,37 @@ static int mdiobb_write(struct mii_bus *
 	mdiobb_get_bit(ctrl);
 	return 0;
 }
+#else
+int mdiobb_write(struct mii_bus *bus, int phy, int reg, u16 val)
+{
+	struct mdiobb_ctrl *ctrl = bus->priv;
+
+	if (reg & MII_ADDR_C45) {
+		reg = mdiobb_cmd_addr(ctrl, phy, reg);
+		mdiobb_cmd(ctrl, MDIO_C45_WRITE, phy, reg);
+	} else
+		mdiobb_cmd(ctrl, MDIO_WRITE, phy, reg);
+
+	/* send the turnaround (10) */
+	mdiobb_send_bit(ctrl, 1);
+	mdiobb_send_bit(ctrl, 0);
+
+	mdiobb_send_num(ctrl, val, 16);
+
+	ctrl->ops->set_mdio_dir(ctrl, 0);
+	mdiobb_get_bit(ctrl);
+	return 0;
+}
+EXPORT_SYMBOL(mdiobb_write);
+
+static int rtl_mdiobb_write(struct mii_bus *bus, int phy, int reg, u16 val)
+{
+	int ret;
+
+	ret = rtk_port_phyReg_set(UTP_PORT0, reg, val);
+	return ret;
+}
+#endif
 
 static int mdiobb_reset(struct mii_bus *bus)
 {
@@ -223,8 +318,13 @@ struct mii_bus *alloc_mdio_bitbang(struc
 
 	__module_get(ctrl->ops->owner);
 
+#ifndef CONFIG_RTL8367_PHY
 	bus->read = mdiobb_read;
 	bus->write = mdiobb_write;
+#else
+	bus->read = rtl_mdiobb_read;
+	bus->write = rtl_mdiobb_write;
+#endif
 	bus->reset = mdiobb_reset;
 	bus->priv = ctrl;
 

--- a/drivers/net/phy/phy_device.c	2018-04-17 18:18:29.836914000 +0900
+++ b/drivers/net/phy/phy_device.c	2018-04-18 11:24:37.237735791 +0900
@@ -1319,6 +1319,7 @@ int genphy_read_status(struct phy_device
 
 		common_adv = lpa & adv;
 
+#ifndef CONFIG_RTL8367_PHY
 		phydev->speed = SPEED_10;
 		phydev->duplex = DUPLEX_HALF;
 		phydev->pause = 0;
@@ -1337,7 +1338,12 @@ int genphy_read_status(struct phy_device
 		} else
 			if (common_adv & LPA_10FULL)
 				phydev->duplex = DUPLEX_FULL;
-
+#else
+		phydev->speed = SPEED_1000;
+		phydev->duplex = DUPLEX_FULL;
+		phydev->pause = 0;
+		phydev->asym_pause = 0;
+#endif
 		if (phydev->duplex == DUPLEX_FULL) {
 			phydev->pause = lpa & LPA_PAUSE_CAP ? 1 : 0;
 			phydev->asym_pause = lpa & LPA_PAUSE_ASYM ? 1 : 0;

--- a/drivers/net/ethernet/renesas/Makefile	2018-04-03 16:17:51.618021000 +0900
+++ a/drivers/net/ethernet/renesas/Makefile	2018-04-18 10:12:24.601677990 +0900
@@ -2,6 +2,8 @@
 # Makefile for the Renesas device drivers.
 #
 
+CFLAGS_ravb_main.o += -I$(srctree)/drivers/net/phy/rtl8367
+
 obj-$(CONFIG_SH_ETH) += sh_eth.o
 
 ravb-objs := ravb_main.o ravb_ptp.o

--- a/drivers/net/ethernet/renesas/ravb_main.c	2018-04-03 16:17:51.618021000 +0900
+++ b/drivers/net/ethernet/renesas/ravb_main.c	2018-04-18 12:05:33.029768553 +0900
@@ -37,6 +37,10 @@
 
 #include <asm/div64.h>
 
+#ifdef CONFIG_RTL8367_PHY
+#include <rtk_switch.h>
+#endif
+
 #include "ravb.h"
 
 #define RAVB_DEF_MSG_ENABLE \
@@ -1080,6 +1084,7 @@ static int ravb_phy_start(struct net_dev
 	return 0;
 }
 
+#ifndef CONFIG_RTL8367_PHY
 static void ravb_phy_reset(struct net_device *ndev)
 {
 	struct ravb_private *priv = netdev_priv(ndev);
@@ -1118,6 +1123,26 @@ static void ravb_phy_reset(struct net_de
 		gpio_set_value(gpio, 1);
 	}
 }
+#else
+static void ravb_phy_reset(struct net_device *ndev)
+{
+	struct device_node *np = ndev->dev.parent->of_node;
+	struct device_node *pn;
+	struct phy_device *phydev;
+
+	pn = of_parse_phandle(np, "phy-handle", 0);
+	if (IS_ERR_OR_NULL(pn))
+		return;
+
+	phydev = of_phy_find_device(pn);
+	if (IS_ERR_OR_NULL(phydev))
+		return;
+
+	phy_read(phydev, MII_BMSR); /* dummy read for rtl8367 */
+	if (phy_read(phydev, MII_BMSR) & BMSR_LSTATUS)
+		return;
+}
+#endif
 
 static int ravb_get_link_ksettings(struct net_device *ndev,
 				   struct ethtool_link_ksettings *cmd)
@@ -1894,6 +1919,10 @@ static int ravb_mdio_init(struct ravb_pr
 	if (error)
 		goto out_free_bus;
 
+#ifdef CONFIG_RTL8367_PHY
+	rtk_switch_init(priv->mii_bus);
+#endif
+
 	return 0;
 
 out_free_bus:

