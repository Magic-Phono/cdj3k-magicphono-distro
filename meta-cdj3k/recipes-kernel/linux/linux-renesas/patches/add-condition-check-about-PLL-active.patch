--- a/drivers/usb/host/xhci-rcar.c	2020-01-06 11:01:38.340665000 +0900
+++ b/drivers/usb/host/xhci-rcar.c	2019-12-27 12:10:34.810895000 +0900
@@ -33,6 +33,7 @@ MODULE_FIRMWARE(XHCI_RCAR_FIRMWARE_NAME_
 MODULE_FIRMWARE(XHCI_RCAR_FIRMWARE_NAME_V3);
 
 /*** Register Offset ***/
+#define RCAR_USB3_AXH_STA	0x104	/* AXI Host Control Status */
 #define RCAR_USB3_INT_ENA	0x224	/* Interrupt Enable */
 #define RCAR_USB3_DL_CTRL	0x250	/* FW Download Control & Status */
 #define RCAR_USB3_FW_DATA0	0x258	/* FW Data0 */
@@ -44,7 +45,17 @@ MODULE_FIRMWARE(XHCI_RCAR_FIRMWARE_NAME_
 #define RCAR_USB3_RX_POL	0xab0	/* USB3.0 RX Polarity */
 #define RCAR_USB3_TX_POL	0xab8	/* USB3.0 TX Polarity */
 
+#ifdef CONFIG_PDJ
+#define RCAR_USB3_PORTSC1	0x420	/* Port1 Status and Control */
+#endif
+
 /*** Register Settings ***/
+/* AXI Host Control Status */
+#define RCAR_USB3_AXH_STA_B3_PLL_ACTIVE		0x00010000
+#define RCAR_USB3_AXH_STA_B2_PLL_ACTIVE		0x00000001
+#define RCAR_USB3_AXH_STA_PLL_ACTIVE_MASK (RCAR_USB3_AXH_STA_B3_PLL_ACTIVE | \
+					   RCAR_USB3_AXH_STA_B2_PLL_ACTIVE)
+
 /* Interrupt Enable */
 #define RCAR_USB3_INT_XHC_ENA	0x00000001
 #define RCAR_USB3_INT_PME_ENA	0x00000002
@@ -131,6 +142,9 @@ void xhci_rcar_start(struct usb_hcd *hcd
 		writel(temp, hcd->regs + RCAR_USB3_INT_ENA);
 		if (xhci_rcar_is_gen2(hcd->self.controller))
 			xhci_rcar_start_gen2(hcd);
+#ifdef CONFIG_PDJ
+		writel(0, hcd->regs + RCAR_USB3_PORTSC1);
+#endif
 	}
 }
 
@@ -211,6 +225,22 @@ static int xhci_rcar_download_firmware(s
 	return retval;
 }
 
+static bool xhci_rcar_wait_for_pll_active(struct usb_hcd *hcd)
+{
+	int timeout = 1000;
+	u32 val, mask = RCAR_USB3_AXH_STA_PLL_ACTIVE_MASK;
+
+	while (timeout > 0) {
+		val = readl(hcd->regs + RCAR_USB3_AXH_STA);
+		if ((val & mask) == mask)
+			return true;
+		udelay(1);
+		timeout--;
+	}
+
+	return false;
+}
+
 /* This function needs to initialize a "phy" of usb before */
 int xhci_rcar_init_quirk(struct usb_hcd *hcd)
 {
@@ -231,6 +261,9 @@ int xhci_rcar_init_quirk(struct usb_hcd
 			xhci_rcar_is_gen3(hcd->self.controller))
 		xhci->quirks |= XHCI_NO_64BIT_SUPPORT;
 
+	if (!xhci_rcar_wait_for_pll_active(hcd))
+		return -ETIMEDOUT;
+
 	xhci->quirks |= XHCI_SLOW_SUSPEND;
 
 	return xhci_rcar_download_firmware(hcd);
